<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Tiro Parab√≥lico - Prototipo Educativo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .game-container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }

        .main-game {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .panel h3 {
            color: #2d3436;
            margin-bottom: 10px;
            font-size: 1.1em;
            border-bottom: 2px solid #74b9ff;
            padding-bottom: 5px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .game-canvas {
            border: 3px solid #333;
            border-radius: 10px;
            display: block;
            margin: 10px auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            background: #87CEEB;
        }

        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 15px 0;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(255, 255, 255, 0.9);
            padding: 12px;
            border-radius: 8px;
            min-width: 120px;
        }

        .control-group label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
            font-size: 0.9em;
        }

        .control-group input[type="range"] {
            width: 80px;
            margin-bottom: 5px;
        }

        .control-group span {
            font-weight: bold;
            color: #e74c3c;
            font-size: 0.9em;
        }

        .action-button {
            padding: 10px 20px;
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            margin: 3px;
        }

        .action-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .reset-button {
            background: linear-gradient(45deg, #74b9ff, #0984e3);
        }

        .physics-display {
            font-size: 0.85em;
            line-height: 1.4;
        }

        .physics-item {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
            padding: 2px 0;
            border-bottom: 1px dotted #ddd;
        }

        .physics-item:last-child {
            border-bottom: none;
        }

        .value {
            font-weight: bold;
            color: #e74c3c;
        }

        .mission-card {
            background: linear-gradient(135deg, #ffeaa7, #fdcb6e);
            padding: 12px;
            border-radius: 8px;
            margin: 8px 0;
            text-align: center;
        }

        .mission-active {
            background: linear-gradient(135deg, #55efc4, #00b894);
            color: white;
        }

        .score-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .score-item {
            background: rgba(255, 255, 255, 0.9);
            padding: 8px;
            border-radius: 6px;
            text-align: center;
        }

        .score-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #e74c3c;
            display: block;
        }

        .score-label {
            font-size: 0.8em;
            color: #666;
        }

        .trajectory-analysis {
            max-height: 150px;
            overflow-y: auto;
            font-size: 0.8em;
        }

        .analysis-item {
            background: rgba(116, 185, 255, 0.1);
            padding: 5px;
            margin: 3px 0;
            border-radius: 4px;
            border-left: 3px solid #74b9ff;
        }

        .mode-selector {
            display: flex;
            gap: 5px;
            margin: 10px 0;
        }

        .mode-button {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8em;
            background: #ddd;
            transition: all 0.2s;
        }

        .mode-button.active {
            background: #74b9ff;
            color: white;
        }

        @media (max-width: 1200px) {
            .game-container {
                grid-template-columns: 1fr;
            }
            
            .sidebar {
                flex-direction: row;
                overflow-x: auto;
            }
            
            .panel {
                min-width: 250px;
            }
        }

        @media (max-width: 768px) {
            .game-canvas {
                width: 100%;
                max-width: 100%;
                height: auto;
            }
            
            .controls {
                gap: 10px;
            }
            
            .control-group {
                min-width: 100px;
                padding: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="main-game">
            <h1>üéØ Simulador de F√≠sica - Tiro Parab√≥lico DEMO V 0.15.1</h1>
            
            <div class="mode-selector">
                <button class="mode-button active" onclick="setGameMode('tutorial')">üìö Tutorial</button>
                <button class="mode-button" onclick="setGameMode('practice')">üéØ Pr√°ctica</button>
                <button class="mode-button" onclick="setGameMode('challenge')">‚ö° Desaf√≠o</button>
                <button class="mode-button" onclick="setGameMode('experiment')">üî¨ Experimento</button>
            </div>

            <canvas id="cannonCanvas" class="game-canvas" width="800" height="400"></canvas>
            
            <div class="controls">
                <div class="control-group">
                    <label>√Ångulo (¬∞)</label>
                    <input type="range" id="cannonAngle" min="0" max="90" value="45">
                    <span id="angleValue">45¬∞</span>
                </div>
                <div class="control-group">
                    <label>Velocidad (m/s)</label>
                    <input type="range" id="cannonPower" min="20" max="100" value="60">
                    <span id="powerValue">60</span>
                </div>
                <div class="control-group">
                    <label>Gravedad (m/s¬≤)</label>
                    <input type="range" id="gravity" min="1" max="20" value="10">
                    <span id="gravityValue">9.8</span>
                </div>
                <div class="control-group">
                    <button class="action-button" onclick="fireCannon()">üöÄ DISPARAR</button>
                    <button class="action-button reset-button" onclick="resetGame()">üîÑ REINICIO</button>
                </div>
            </div>
        </div>

        <div class="sidebar">
            <div class="panel">
                <h3>üî¨ F√≠sica en Tiempo Real</h3>
                <div class="physics-display" id="physicsDisplay">
                    <div class="physics-item">
                        <span>Velocidad inicial:</span>
                        <span class="value" id="v0">0 m/s</span>
                    </div>
                    <div class="physics-item">
                        <span>Componente Vx:</span>
                        <span class="value" id="vx">0 m/s</span>
                    </div>
                    <div class="physics-item">
                        <span>Componente Vy:</span>
                        <span class="value" id="vy">0 m/s</span>
                    </div>
                    <div class="physics-item">
                        <span>Tiempo de vuelo:</span>
                        <span class="value" id="flightTime">0 s</span>
                    </div>
                    <div class="physics-item">
                        <span>Altura m√°xima:</span>
                        <span class="value" id="maxHeight">0 m</span>
                    </div>
                    <div class="physics-item">
                        <span>Alcance te√≥rico:</span>
                        <span class="value" id="range">0 m</span>
                    </div>
                    <div class="physics-item">
                        <span>Energ√≠a cin√©tica:</span>
                        <span class="value" id="kineticEnergy">0 J</span>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>üéØ Misi√≥n Actual</h3>
                <div class="mission-card" id="currentMission">
                    <strong>Tutorial:</strong><br>
                    Aprende los controles b√°sicos disparando al primer blanco
                </div>
                <div style="text-align: center; margin-top: 10px;">
                    <button class="action-button" onclick="nextMission()">‚û°Ô∏è Siguiente</button>
                </div>
            </div>

            <div class="panel">
                <h3>üìä Estad√≠sticas</h3>
                <div class="score-grid">
                    <div class="score-item">
                        <span class="score-value" id="score">0</span>
                        <div class="score-label">Puntos</div>
                    </div>
                    <div class="score-item">
                        <span class="score-value" id="shots">0</span>
                        <div class="score-label">Disparos</div>
                    </div>
                    <div class="score-item">
                        <span class="score-value" id="accuracy">0%</span>
                        <div class="score-label">Precisi√≥n</div>
                    </div>
                    <div class="score-item">
                        <span class="score-value" id="level">1</span>
                        <div class="score-label">Nivel</div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>üìà An√°lisis de Tiros</h3>
                <div class="trajectory-analysis" id="trajectoryAnalysis">
                    <div style="text-align: center; color: #666; font-style: italic;">
                        Los an√°lisis de tus disparos aparecer√°n aqu√≠
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Variables globales del juego mejorado
        let game = {
            canvas: null,
            ctx: null,
            cannonX: 50,
            cannonY: 350,
            targets: [],
            projectiles: [],
            explosions: [],
            particles: [],
            trajectoryHistory: [],
            predictedTrajectory: [],
            score: 0,
            shots: 0,
            level: 1,
            gameMode: 'tutorial',
            currentMission: 0,
            missions: [
                { type: 'tutorial', description: 'Dispara al primer blanco para aprender', target: 1, reward: 100 },
                { type: 'precision', description: 'Destruye 3 blancos con m√°ximo 5 disparos', target: 3, maxShots: 5, reward: 300 },
                { type: 'physics', description: 'Usa solo √°ngulos entre 30-60¬∞', target: 2, angleMin: 30, angleMax: 60, reward: 200 },
                { type: 'efficiency', description: 'M√°xima puntuaci√≥n con m√≠nimos disparos', target: 5, reward: 500 },
                { type: 'experiment', description: 'Cambia la gravedad y destruye todos los blancos', target: 4, reward: 400 }
            ],
            physicsData: {
                mass: 1, // kg
                gravity: 9.8
            }
        };

        // Inicializar el juego
        function initGame() {
            game.canvas = document.getElementById('cannonCanvas');
            game.ctx = game.canvas.getContext('2d');
            
            createTargets();
            resetStats();
            updateControls();
            updatePhysicsDisplay();
            updateMissionDisplay();
            animate();
        }

        // Crear blancos seg√∫n el nivel
        function createTargets() {
            game.targets = [];
            const numTargets = Math.min(3 + game.level, 8);
            
            for (let i = 0; i < numTargets; i++) {
                game.targets.push({
                    x: 300 + Math.random() * 450,
                    y: 100 + Math.random() * 200,
                    width: 25 + Math.random() * 15,
                    height: 25 + Math.random() * 15,
                    destroyed: false,
                    value: 50 + Math.floor(Math.random() * 50)
                });
            }
        }

        // Establecer modo de juego
        function setGameMode(mode) {
            game.gameMode = mode;
            document.querySelectorAll('.mode-button').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            switch(mode) {
                case 'tutorial':
                    game.currentMission = 0;
                    break;
                case 'challenge':
                    game.currentMission = 1;
                    break;
                case 'experiment':
                    document.getElementById('gravity').style.display = 'block';
                    break;
            }
            
            updateMissionDisplay();
            resetGame();
        }

        // Actualizar controles
        function updateControls() {
            const angleSlider = document.getElementById('cannonAngle');
            const powerSlider = document.getElementById('cannonPower');
            const gravitySlider = document.getElementById('gravity');
            
            angleSlider.oninput = () => {
                document.getElementById('angleValue').textContent = angleSlider.value + '¬∞';
                updatePhysicsDisplay();
                calculateTrajectoryPrediction();
            };
            
            powerSlider.oninput = () => {
                document.getElementById('powerValue').textContent = powerSlider.value;
                updatePhysicsDisplay();
                calculateTrajectoryPrediction();
            };
            
            gravitySlider.oninput = () => {
                const gravity = parseFloat(gravitySlider.value);
                game.physicsData.gravity = gravity;
                document.getElementById('gravityValue').textContent = gravity.toFixed(1);
                updatePhysicsDisplay();
                calculateTrajectoryPrediction();
            };
        }

        // Actualizar display de f√≠sica
        function updatePhysicsDisplay() {
            const angle = parseFloat(document.getElementById('cannonAngle').value);
            const power = parseFloat(document.getElementById('cannonPower').value);
            const gravity = game.physicsData.gravity;
            
            const angleRad = (angle * Math.PI) / 180;
            const v0 = power;
            const vx = v0 * Math.cos(angleRad);
            const vy = v0 * Math.sin(angleRad);
            
            const flightTime = (2 * vy) / gravity;
            const maxHeight = (vy * vy) / (2 * gravity);
            const range = (v0 * v0 * Math.sin(2 * angleRad)) / gravity;
            const kineticEnergy = 0.5 * game.physicsData.mass * v0 * v0;
            
            document.getElementById('v0').textContent = v0.toFixed(1) + ' m/s';
            document.getElementById('vx').textContent = vx.toFixed(1) + ' m/s';
            document.getElementById('vy').textContent = vy.toFixed(1) + ' m/s';
            document.getElementById('flightTime').textContent = flightTime.toFixed(2) + ' s';
            document.getElementById('maxHeight').textContent = maxHeight.toFixed(1) + ' m';
            document.getElementById('range').textContent = range.toFixed(1) + ' m';
            document.getElementById('kineticEnergy').textContent = kineticEnergy.toFixed(0) + ' J';
        }

        // Calcular trayectoria predicha
        function calculateTrajectoryPrediction() {
            const angle = parseFloat(document.getElementById('cannonAngle').value);
            const power = parseFloat(document.getElementById('cannonPower').value);
            
            const angleRad = (angle * Math.PI) / 180;
            const velocity = power * 0.4; // Escala para canvas
            const gravity = game.physicsData.gravity * 0.02; // Escala para canvas
            
            game.predictedTrajectory = [];
            
            let x = game.cannonX + Math.cos(angleRad) * 40;
            let y = game.cannonY - Math.sin(angleRad) * 40;
            let vx = Math.cos(angleRad) * velocity;
            let vy = -Math.sin(angleRad) * velocity;
            
            for (let i = 0; i < 300; i++) {
                game.predictedTrajectory.push({x: x, y: y});
                x += vx;
                y += vy;
                vy += gravity;
                
                if (y >= 380 || x > game.canvas.width || x < 0) break;
            }
        }

        // Disparar ca√±√≥n
        function fireCannon() {
            const angle = parseFloat(document.getElementById('cannonAngle').value);
            const power = parseFloat(document.getElementById('cannonPower').value);
            
            // Verificar restricciones de misi√≥n
            const mission = game.missions[game.currentMission];
            if (mission.angleMin && (angle < mission.angleMin || angle > mission.angleMax)) {
                addTrajectoryAnalysis(`‚ùå √Ångulo fuera del rango permitido (${mission.angleMin}¬∞-${mission.angleMax}¬∞)`);
                return;
            }
            
            if (mission.maxShots && game.shots >= mission.maxShots) {
                addTrajectoryAnalysis(`‚ùå Has alcanzado el l√≠mite de disparos (${mission.maxShots})`);
                return;
            }
            
            const angleRad = (angle * Math.PI) / 180;
            const velocity = power * 0.4;
            const gravity = game.physicsData.gravity * 0.02;
            
            const projectile = {
                x: game.cannonX + Math.cos(angleRad) * 40,
                y: game.cannonY - Math.sin(angleRad) * 40,
                vx: Math.cos(angleRad) * velocity,
                vy: -Math.sin(angleRad) * velocity,
                gravity: gravity,
                trail: [],
                startTime: Date.now(),
                angle: angle,
                initialPower: power
            };

            game.projectiles.push(projectile);
            game.shots++;
            
            createMuzzleFlash(angleRad);
            updateStats();
        }

        // Crear flash del ca√±√≥n
        function createMuzzleFlash(angle) {
            for (let i = 0; i < 10; i++) {
                game.particles.push({
                    x: game.cannonX + Math.cos(angle) * 40,
                    y: game.cannonY - Math.sin(angle) * 40,
                    vx: Math.cos(angle + (Math.random() - 0.5) * 0.5) * (2 + Math.random() * 4),
                    vy: -Math.sin(angle + (Math.random() - 0.5) * 0.5) * (2 + Math.random() * 4),
                    life: 20,
                    maxLife: 20,
                    color: Math.random() > 0.5 ? '#FFD700' : '#FF4500'
                });
            }
        }

        // Crear explosi√≥n
        function createExplosion(x, y, size = 40) {
            game.explosions.push({
                x: x,
                y: y,
                radius: 0,
                maxRadius: size,
                alpha: 1,
                life: 30
            });
            
            for (let i = 0; i < 15; i++) {
                game.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: 25,
                    maxLife: 25,
                    color: ['#FFD700', '#FF4500', '#FF6B35'][Math.floor(Math.random() * 3)]
                });
            }
        }

        // Agregar an√°lisis de trayectoria
        function addTrajectoryAnalysis(text) {
            const analysisDiv = document.getElementById('trajectoryAnalysis');
            const item = document.createElement('div');
            item.className = 'analysis-item';
            item.textContent = text;
            
            analysisDiv.insertBefore(item, analysisDiv.firstChild);
            
            // Mantener solo los √∫ltimos 10 an√°lisis
            while (analysisDiv.children.length > 10) {
                analysisDiv.removeChild(analysisDiv.lastChild);
            }
        }

        // Actualizar misi√≥n
        function updateMissionDisplay() {
            const mission = game.missions[game.currentMission];
            const missionDiv = document.getElementById('currentMission');
            
            missionDiv.innerHTML = `
                <strong>${mission.type.toUpperCase()}:</strong><br>
                ${mission.description}<br>
                <small>Recompensa: ${mission.reward} puntos</small>
            `;
        }

        // Siguiente misi√≥n
        function nextMission() {
            if (game.currentMission < game.missions.length - 1) {
                game.currentMission++;
                updateMissionDisplay();
                resetGame();
            } else {
                addTrajectoryAnalysis('üéâ ¬°Has completado todas las misiones!');
            }
        }

        // Bucle principal de animaci√≥n
        function animate() {
            game.ctx.clearRect(0, 0, game.canvas.width, game.canvas.height);
            
            // Fondo con degradado
            const gradient = game.ctx.createLinearGradient(0, 0, 0, game.canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(0.7, '#98FB98');
            gradient.addColorStop(1, '#8FBC8F');
            game.ctx.fillStyle = gradient;
            game.ctx.fillRect(0, 0, game.canvas.width, game.canvas.height);
            
            // Suelo
            game.ctx.fillStyle = '#8B4513';
            game.ctx.fillRect(0, 380, game.canvas.width, 20);
            
            // Dibujar trayectoria predicha
            drawTrajectoryPrediction();
            
            // Dibujar elementos del juego
            drawCannon();
            drawTargets();
            updateProjectiles();
            updateExplosions();
            updateParticles();
            
            requestAnimationFrame(animate);
        }

        // Dibujar trayectoria predicha
        function drawTrajectoryPrediction() {
            if (game.predictedTrajectory.length > 1) {
                game.ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
                game.ctx.lineWidth = 2;
                game.ctx.setLineDash([5, 5]);
                game.ctx.beginPath();
                game.predictedTrajectory.forEach((point, index) => {
                    if (index === 0) {
                        game.ctx.moveTo(point.x, point.y);
                    } else {
                        game.ctx.lineTo(point.x, point.y);
                    }
                });
                game.ctx.stroke();
                game.ctx.setLineDash([]);
            }
        }

        // Dibujar ca√±√≥n
        function drawCannon() {
            const angle = parseFloat(document.getElementById('cannonAngle').value);
            const angleRad = -(angle * Math.PI) / 180;
            
            game.ctx.save();
            
            // Base del ca√±√≥n
            game.ctx.fillStyle = '#2c3e50';
            game.ctx.beginPath();
            game.ctx.arc(game.cannonX, game.cannonY, 20, 0, Math.PI * 2);
            game.ctx.fill();
            
            // Barril
            game.ctx.translate(game.cannonX, game.cannonY);
            game.ctx.rotate(angleRad);
            game.ctx.fillStyle = '#34495e';
            game.ctx.fillRect(0, -6, 35, 12);
            
            game.ctx.restore();
        }

        // Dibujar blancos
        function drawTargets() {
            game.targets.forEach(target => {
                if (!target.destroyed) {
                    game.ctx.fillStyle = '#e74c3c';
                    game.ctx.fillRect(target.x, target.y, target.width, target.height);
                    
                    game.ctx.strokeStyle = '#c0392b';
                    game.ctx.lineWidth = 2;
                    game.ctx.strokeRect(target.x, target.y, target.width, target.height);
                    
                    // Mostrar valor del blanco
                    game.ctx.fillStyle = 'white';
                    game.ctx.font = '12px Arial';
                    game.ctx.textAlign = 'center';
                    game.ctx.fillText(target.value, target.x + target.width/2, target.y + target.height/2 + 4);
                }
            });
        }

        // Actualizar proyectiles
        function updateProjectiles() {
            game.projectiles = game.projectiles.filter(projectile => {
                projectile.x += projectile.vx;
                projectile.y += projectile.vy;
                projectile.vy += projectile.gravity;
                
                projectile.trail.push({x: projectile.x, y: projectile.y});
                if (projectile.trail.length > 15) {
                    projectile.trail.shift();
                }
                
                // Dibujar rastro
                if (projectile.trail.length > 1) {
                    game.ctx.strokeStyle = 'rgba(255, 215, 0, 0.6)';
                    game.ctx.lineWidth = 3;
                    game.ctx.beginPath();
                    projectile.trail.forEach((point, index) => {
                        if (index === 0) {
                            game.ctx.moveTo(point.x, point.y);
                        } else {
                            game.ctx.lineTo(point.x, point.y);
                        }
                    });
                    game.ctx.stroke();
                }
                
                // Dibujar proyectil
                game.ctx.fillStyle = '#f39c12';
                game.ctx.beginPath();
                game.ctx.arc(projectile.x, projectile.y, 6, 0, Math.PI * 2);
                game.ctx.fill();
                
                // Verificar colisiones con blancos
                let hit = false;
                game.targets.forEach((target, index) => {
                    if (!target.destroyed &&
                        projectile.x >= target.x && projectile.x <= target.x + target.width &&
                        projectile.y >= target.y && projectile.y <= target.y + target.height) {
                        
                        target.destroyed = true;
                        game.score += target.value;
                        hit = true;
                        
                        createExplosion(target.x + target.width/2, target.y + target.height/2, 50);
                        
                        // An√°lisis del tiro exitoso
                        const flightTime = (Date.now() - projectile.startTime) / 1000;
                        addTrajectoryAnalysis(`üéØ ¬°Blanco destruido! +${target.value} pts (${flightTime.toFixed(1)}s, ${projectile.angle}¬∞)`);
                        
                        updateStats();
                        checkMissionComplete();
                    }
                });
                
                // Eliminar proyectil si toca el suelo o sale de pantalla
                if (projectile.y >= 380 || projectile.x > game.canvas.width || projectile.x < 0 || hit) {
                    if (projectile.y >= 380 && !hit) {
                        createExplosion(projectile.x, 380, 25);
                        addTrajectoryAnalysis(`üí• Impacto en el suelo (${projectile.angle}¬∞, velocidad: ${projectile.initialPower})`);
                    }
                    return false;
                }
                
                return true;
            });
        }

        // Actualizar explosiones
        function updateExplosions() {
            game.explosions = game.explosions.filter(explosion => {
                explosion.life--;
                explosion.radius = (1 - explosion.life / 30) * explosion.maxRadius;
                explosion.alpha = explosion.life / 30;
                
                if (explosion.alpha > 0) {
                    const gradient = game.ctx.createRadialGradient(
                        explosion.x, explosion.y, 0,
                        explosion.x, explosion.y, explosion.radius
                    );
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${explosion.alpha})`);
                    gradient.addColorStop(0.4, `rgba(255, 215, 0, ${explosion.alpha * 0.8})`);
                    gradient.addColorStop(0.8, `rgba(255, 69, 0, ${explosion.alpha * 0.6})`);
                    gradient.addColorStop(1, `rgba(139, 0, 0, ${explosion.alpha * 0.3})`);
                    
                    game.ctx.fillStyle = gradient;
                    game.ctx.beginPath();
                    game.ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
                    game.ctx.fill();
                    
                    return true;
                }
                return false;
            });
        }

        // Actualizar part√≠culas
        function updateParticles() {
            game.particles = game.particles.filter(particle => {
                particle.life--;
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vy += 0.1;
                
                const alpha = particle.life / particle.maxLife;
                if (alpha > 0) {
                    game.ctx.fillStyle = particle.color;
                    game.ctx.globalAlpha = alpha;
                    game.ctx.beginPath();
                    game.ctx.arc(particle.x, particle.y, 2, 0, Math.PI * 2);
                    game.ctx.fill();
                    game.ctx.globalAlpha = 1;
                    
                    return true;
                }
                return false;
            });
        }

        // Verificar si la misi√≥n est√° completa
        function checkMissionComplete() {
            const mission = game.missions[game.currentMission];
            const targetsDestroyed = game.targets.filter(t => t.destroyed).length;
            
            let completed = false;
            
            switch(mission.type) {
                case 'tutorial':
                    completed = targetsDestroyed >= mission.target;
                    break;
                case 'precision':
                    completed = targetsDestroyed >= mission.target && game.shots <= mission.maxShots;
                    break;
                case 'physics':
                    completed = targetsDestroyed >= mission.target;
                    break;
                case 'efficiency':
                    completed = targetsDestroyed >= mission.target;
                    break;
                case 'experiment':
                    completed = targetsDestroyed >= mission.target;
                    break;
            }
            
            if (completed) {
                game.score += mission.reward;
                addTrajectoryAnalysis(`üåü ¬°Misi√≥n completada! +${mission.reward} puntos bonus`);
                
                setTimeout(() => {
                    if (game.currentMission < game.missions.length - 1) {
                        game.currentMission++;
                        updateMissionDisplay();
                        levelUp();
                    } else {
                        addTrajectoryAnalysis('üèÜ ¬°Felicidades! Has completado todas las misiones');
                    }
                }, 1500);
            }
        }

        // Subir de nivel
        function levelUp() {
            game.level++;
            addTrajectoryAnalysis(`üî• ¬°Nivel ${game.level}! Nuevos desaf√≠os te esperan`);
            createTargets();
            resetStats(false); // No resetear puntuaci√≥n total
        }

        // Resetear estad√≠sticas
        function resetStats(resetScore = true) {
            if (resetScore) {
                game.score = 0;
                game.level = 1;
            }
            game.shots = 0;
            game.projectiles = [];
            game.explosions = [];
            game.particles = [];
            updateStats();
        }

        // Actualizar estad√≠sticas en pantalla
        function updateStats() {
            document.getElementById('score').textContent = game.score;
            document.getElementById('shots').textContent = game.shots;
            document.getElementById('level').textContent = game.level;
            
            const targetsDestroyed = game.targets.filter(t => t.destroyed).length;
            const accuracy = game.shots > 0 ? Math.round((targetsDestroyed / game.shots) * 100) : 0;
            document.getElementById('accuracy').textContent = accuracy + '%';
        }

        // Resetear juego
        function resetGame() {
            createTargets();
            resetStats();
            document.getElementById('trajectoryAnalysis').innerHTML = 
                '<div style="text-align: center; color: #666; font-style: italic;">Los an√°lisis de tus disparos aparecer√°n aqu√≠</div>';
        }

        // Controles de teclado
        document.addEventListener('keydown', (event) => {
            switch(event.key) {
                case 'ArrowUp':
                    adjustControl('cannonAngle', 1);
                    event.preventDefault();
                    break;
                case 'ArrowDown':
                    adjustControl('cannonAngle', -1);
                    event.preventDefault();
                    break;
                case 'ArrowLeft':
                    adjustControl('cannonPower', -2);
                    event.preventDefault();
                    break;
                case 'ArrowRight':
                    adjustControl('cannonPower', 2);
                    event.preventDefault();
                    break;
                case ' ':
                    fireCannon();
                    event.preventDefault();
                    break;
                case 'r':
                case 'R':
                    resetGame();
                    event.preventDefault();
                    break;
                case '1':
                    setGameModeByIndex(0);
                    event.preventDefault();
                    break;
                case '2':
                    setGameModeByIndex(1);
                    event.preventDefault();
                    break;
                case '3':
                    setGameModeByIndex(2);
                    event.preventDefault();
                    break;
                case '4':
                    setGameModeByIndex(3);
                    event.preventDefault();
                    break;
            }
        });

        // Ajustar control por teclado
        function adjustControl(controlId, change) {
            const control = document.getElementById(controlId);
            let newValue = parseInt(control.value) + change;
            newValue = Math.max(parseInt(control.min), Math.min(parseInt(control.max), newValue));
            control.value = newValue;
            control.oninput();
        }

        // Establecer modo de juego por √≠ndice
        function setGameModeByIndex(index) {
            const modes = ['tutorial', 'practice', 'challenge', 'experiment'];
            if (modes[index]) {
                const buttons = document.querySelectorAll('.mode-button');
                buttons[index].click();
            }
        }

        // Agregar consejos educativos
        function addPhysicsTip() {
            const tips = [
                "üí° El √°ngulo de 45¬∞ maximiza el alcance en condiciones ideales",
                "üî¨ La componente horizontal de velocidad permanece constante (sin resistencia del aire)",
                "üìê Dos √°ngulos diferentes pueden dar el mismo alcance: Œ± y (90¬∞-Œ±)",
                "‚ö° La energ√≠a cin√©tica se convierte en potencial en el punto m√°s alto",
                "üåç En la Luna (g=1.6 m/s¬≤) los proyectiles vuelan mucho m√°s lejos",
                "üìä El tiempo de vuelo depende solo de la componente vertical de velocidad"
            ];
            
            const randomTip = tips[Math.floor(Math.random() * tips.length)];
            addTrajectoryAnalysis(randomTip);
        }

        // Agregar tips peri√≥dicamente
        setInterval(addPhysicsTip, 30000); // Cada 30 segundos

        // Inicializar el juego cuando cargue la p√°gina
        window.addEventListener('load', () => {
            initGame();
            updateControls();
            calculateTrajectoryPrediction();
            
            // Mensaje de bienvenida
            setTimeout(() => {
                addTrajectoryAnalysis("üöÄ ¬°Bienvenido al Simulador de F√≠sica!");
                addTrajectoryAnalysis("‚å®Ô∏è Usa las flechas del teclado para controlar, ESPACIO para disparar");
            }, 1000);
        });

        // Manejar redimensionado responsive
        window.addEventListener('resize', () => {
            const canvas = game.canvas;
            if (canvas && window.innerWidth < 900) {
                canvas.style.width = '100%';
                canvas.style.height = 'auto';
            }
        });
    </script>
</body>
</html>
